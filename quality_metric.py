# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DZqGaaqLl9ohYxznp-CHlv6uM3xogglX
"""

# вход – список с элементами 0 1 2 (0 нет пропаганды, 1 - начало пропаганды, 2 - внутри пропаганды)

import numpy as np

def score(y_trues, y_preds):
    '''
    Версия 1:

    На вход подается numpy массив y_trues, y_preds

    Для каждой манипуляции в каждом тексте в y_trues ищем расстояние до ближайшей манипуляции
    в соответствующем тексте y_preds (пока без учёта длины пересечения)

    Находим среднее расстояние по тексту и записываем в список scores

    Возвращаем среднее по всем текстам
    '''
    # esxception на равную размерность массивов
    if y_trues.shape != y_preds.shape:
        print('Error: Размерности фходных массивов не совпадают')
        return None
    
    scores = []
    for z in range(len(y_trues)):
        y_true = y_trues[z]
        y_pred = y_preds[z]

        # список вхождений манипуляций
        manip_list = [] # список [[начало, конец], [], [], ...] манипуляций
        for i in range(len(y_true)):
            if y_true[i] == 1:
                for j in range(i + 1, len(y_true)):
                    if y_true[j] != 2:
                        manip_list.append([i, j])
                        break
        if y_true[i] == 1:
            manip_list.append([i, i + 1])

        dists = [] # список расстояний до болижайшего (левого, если расстояние одинаково) начала манипуляции
        n = -1
        for i, j in manip_list:
            n += 1
            dists.append(len(y_pred)) 
            for k in range(len(y_pred) - dists[n], len(y_pred)):
                if y_pred[k] == 1 and abs(i-k) < dists[n]:
                    dists[n] = abs(i-k)

        scores.append(sum(dists)/len(dists))
        
        # стараемся минимизировать метрику
    return (sum(scores)/len(scores))
